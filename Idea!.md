Not semi-persistent, but I have an idea for a [persistent bit-partitioned vector trie](https://hypirion.com/musings/understanding-persistent-vector-pt-2#fnref:1), like Philip Bagwell's/Rich Hickey's, but that keeps its most recently modified array contiguous in memory. The pointers to leaves might actually need to be pointers to indices, effectively pointers-to-pointers, to allow that underlying array to grow/move and to allow a modified vector to modify copy the elements of other vectors' - with which it shares data - to their own nodes. It probably won't strictly be the "most recently modified" vector whose contents are always contiguous in memory, but rather the one most recently modified assuming older vectors are only read, not written to (*partially* persistent style). However, the semantics will be fully persistent - the older vectors will simply have the rough performance characteristics of a [persistent bit-partitioned vector trie](https://hypirion.com/musings/understanding-persistent-vector-pt-2#fnref:1).
A proposed use case would be building a large vector that could then be frozen, but which also needs a history. It would perform *decently* well while being frozen, but then *really* well while just being read. If it were instead a [Hash Array Mapped Trie](https://en.wikipedia.org/wiki/Hash_array_mapped_trie) (also Bagwell's), and I think it could be, this might be a really good fit for mapping names to types in, say, an interpreter for a language with lots of local variables in the innermost scope but comparatively few outer variables, that gets processed in phases. But because this is my first time trying this, and I certainly haven't considered everything (I don't even totally know if it will work!) I would be really surprised if it would behave much better than anything else. For instance, it would not have particularly appealing performance characteristics if there were local scopes within functions like in C.